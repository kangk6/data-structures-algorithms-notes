# chapter1 - notes
## 一、绪论
### 1.2 基本概念和术语

1. 数据：数值型和非数值型

2. 数据元素：数据的基本单位，一个整体，也叫做元素，记录，结点，顶点

3. 数据项：构成数据元素的不可分割的最小单位
   - 数据>数据元素>数据项

4. 数据对象：性质相同的数据元素的集合，是数据的子集

5. 数据结构：带结构的数据元素的集合
   - 结构：数据元素之间的关系叫做结构
   - 数据结构包括：逻辑结构，物理结构（存储结构），数据的运算和实现
     - 逻辑结构：描述数据元素之间的逻辑关系，与数据的存储无关，是从具体问题抽象出来的数学模型
       - 种类：
         - 划分方法一：线性结构，例如线性表、栈、队列、串；非线性结构，例如树、图
         - 划分方法二：四种基本逻辑结构：集合，线性结构，树形结构，图形结构
     - 物理结构（存储结构）：数据元素及其关系在计算机存储器中的结构（存储方式），是数据结构在计算机中的表示
       - 种类：顺序存储结构，链式存储结构，索引存储结构，散列存储结构
         - 顺序存储结构：用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示，C语言中用数组来实现顺序存储结构
         - 链式存储结构：用一组任意的存储单元存储数据元素，属于元素之间的逻辑关系用指针来表示，C语言中用指针来实现链式存储结构。
     - 两者关系：
       1. 存储结构是逻辑关系的映象和元素本身的映象
       2. 逻辑结构是数据结构的抽象，存储结构是数据结构的实现
       3. 两者综合起来建立了数据元素之间的结构关系
6. 数据类型：数据类型是一组性质相同的**值的集合**以及定义于这个值集合上的**一组操作**的总称
   - 作用：
     - 约束变量或常量的取值范围
     - 约束变量或常量的操作
7. 抽象数据类型（**A**bstract **D**ata **T**ype, ADT）：是指一个数学模型以及定义在此数学模型上的一组操作
   - 由用户定义，从问题抽象出数据模型（逻辑结构）
   - 还包括定义在数据模型上的一组抽象运算（相关操作）
   - 不考虑计算机内的具体存储结构与运算的具体实现算法
   - 抽象数据类型的形式定义：
     - 抽象数据类型可用（D, S, P）三元组表示

       其中：D是数据对象；
             S是D上的关系集；
             P是对D的基本操作集。
   - 定义格式：
     ```
     ADT 抽象数据类型名 {
     数据对象:<数据对象的定义>
     数据关系:< 数据关系的定义 >
     基本操作:< 基本操作的定义 >
     } ADT 抽象数据类型名
     ```
     - 其中:
       - 数据对象、数据关系的定义用伪代码描述
       - 基本操作的定义格式为:
         - 基本操作名（参数表）
           - 参数表：
             - 赋值参数：只为操作提供输入值
             - 引用参数：以&打头，除可提供输入值外，还将返回操作结果
         - 初始条件：〈初始条件描述〉
           - 描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。
         - 操作结果：〈操作结果描述〉
           - 说明操作正常完成之后，数据结构的变化状况和应返回的结果
     - 两个例子
       - Circle的定义：<img width="745" height="347" alt="image" src="https://github.com/user-attachments/assets/7092584b-97bf-4490-b9e0-5b5451f8636f" />
       - 复数的定义：<img width="702" height="324" alt="image" src="https://github.com/user-attachments/assets/c9b9517e-c200-4d19-9192-b33af98bdfbb" />
### 1.3 抽象数据类型的表示与实现
在本门课程的学习过程中，我们使用类C语言（介于伪码和C语言之间）作为描述工具
1. 抽象数据类型复数的实现：
   ```c
   typedef struct {
    float realpart;//实部
    float imagpart;//虚部
   }Complex;//定义复数抽象类型
   void assign(Complex* A, float real, float imag);   /* 赋值 */
   void add(Complex* A, float real, float imag);   /* A + B */
   void minus(Complex* A, float real, float imag);  /* A - B */
   void multiply(Complex* A, float real, float imag);/* A * B */
   void divide(Complex* A, float real, float imag);  /* A / B */
   void assign(Complex* A, float real, float imag) {
       A->realpart = real;           /* 实部赋值 */
       A->imagpart = imag;            /* 虚部赋值 */
       /* End of assign() */
   }
   
   void add(Complex* c, Complex A, Complex B) {   /* c = A + B */
       c->realpart = A.realpart + B.realpart;   /* 实部相加 */
       c->imagpart = A.imagpart + B.imagpart;    /* 虚部相加 */
       /* End of Add() */
   }
   ```
### 1.4 算法和算法分析
1. 算法五个特性：有穷性，确定性，可行性，输入(>=0)，输出(>=1)
2. 算法设计的要求：正确性，可读性，健壮性，高效性
3. 判断好的算法：首先满足正确性，可读性，健壮性，然后主要考虑**算法的效率**
   - 时间效率和空间效率
   - 算法时间效率的度量：在计算机上执行所消耗的时间
     - 算法运行时间 = $\sum$每条语句的执行次数（语句频度）×该语句执行一次所需的时间
       - 注：我们假设执行每条语句所需的时间均为单位时间，因此可以直接比较每条语句的频度之和
       - 算法描述（两个 n $\times$ n 矩阵相乘）：
         ```c
         for(i=1; i<=n; i++)          // n+1 次  
            for(j=1; j<=n; j++) {      //  n(n+1) 次  
               c[i][j] = 0;           //  $n^2$ 次  
               for(k=0; k<n; k++) {   // $n^2(n+1)$ 次  
                  c[i][j] += a[i][k] * b[k][j];  //  n^3  次  
               }  
            }  
         ```

         每条语句的频度之和：T(n) = 2n^3 + 3n^2 + 2n + 1
   - 为了便于比较不同算法的时间效率，我们仅比较他们的数量级
     - 若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n)/f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数。记作 T(n) = O(f(n))，称 O(f(n)) 为算法的渐进时间复杂度（O 是数量级的符号），简称时间复杂度。
   - 分析时间复杂度的基本方法
     - e.g.
       代码结构：
       ```c
       for (i=1; i<=n; i++) {
          for (j=1; j<=i; j++) {
             for (k=1; k<=j; k++) {
                x = x + 1;  // 语句频度计算对象
             }
          }
       }
       ```
       数学表达式：
语句频度 = $\sum_{i=1}^{n} \sum_{j=1}^{i} \sum_{k=1}^{j} 1 = \sum_{i=1}^{n} \sum_{j=1}^{i} j = \sum_{i=1}^{n} \frac{i(i+1)}{2}$
​       - 注：从这里可以看出改用级数求和比较便于计算
     - e.g.
       代码结构：
       ```c
       i = 1;
       while(i <= n) {
          i *= 2;
       }
       ```
       思路：这里时间复杂度的本质是**执行次数**，因此不妨令执行次数为x，即**若循环执行x次，则i = 2^x**，而**若循环能够执行，则i <= n，即2^x <= n**，故x <= $\log_{2}(n)$，因此时间复杂度O( $\log_{2}(n)$ )
       - 注：我们在时间复杂度中一般不加区分对数的底数
     - e.g.
       代码结构：
       ```c
       for(i = 0; i < n; i++) {
          if(a[i] == e) {
             return i + 1;
          }
          return 0;
       }
       ```
       这个例子说明算法中基本操作重复执行的次数还随问题输入数据集不同而不同

       因此出现最坏时间复杂度，平均时间复杂度，最好时间复杂度

       此外，对于复杂的算法，可以将它分成几个容易估算的部分，然后利用加法法则和乘法法则，计算算法的时间复杂度
       1. 加法法则
       T(n) = T1(n) + T2(n) = O(F(n)) + O(g(n)) = O(max(f(n), g(n)))
       2. 乘法法则
       T(n) = T1(n) * T2(n) = O(F(n)) * O(g(n)) = O(f(n)*g(n))
   - 算法时间效率的比较
     - 当n很大时，指数时间算法所需时间 >> 多项式时间算法所需时间
     - 1 < logn < n < nlogn < n^2 < n^3 < 2^n < n!
   - 算法空间效率的度量——（渐近）空间复杂度
     - 算法要占据的空间：算法本身要占据的空间，输入/输出，指令，常数，变量等以及算法要使用的辅助空间
     - e.g.将一维数组a中的n个数逆序存放在原数组中
       ```c
       //算法一
       for(i = 0; i < n/2; i++) {
          t = a[i];
          a[i] = a[n - i - 1];
          a[n - i - 1] = t;
       }
       ```
       这里t就是辅助空间 S(n) = O(1)（原地工作），只用了一个变量
       ```c
       //算法二
       for(i = 0; i < n; i++) {
          b[i] = a[n - i - 1];
       }
       for(i = 0; i < n; i++) {
          a[i] = b[i];
       }
       ```
       S(n) = O(n)
